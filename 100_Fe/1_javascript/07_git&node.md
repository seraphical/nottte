git 是一个分布式版本管理器,帮助开发人员更好地进行协作

# 初始配置
- 不是基于 node 环境运行的
    - 不能使用 npm 安装
- 是基于操作系统运行
- 需要官网下载安装包, 手动安装
- 安装过程:一路下一步
- 检测:
    - 命令行
    - `$git --version`
    - 简写 `git -v`

## git 首次安装需要进行的配置
- 注意: 该电脑第一次安装的时候需要进行的配置
    - 安装过, 配置好后卸载了 git, 再次安装不需要配置
    - 只要你的配置文件不删除, 就不需要再次配置
- 为什么需要配置
    - 因为将来 git 会记录你的所有版本(历史节点)
    - 在生成历史节点的时候, 需要有签名(记录你的名字和邮箱)
    - 所以需要配置全局用户名和邮箱
- 配置方式
     - 查看全局配置列表
         - 打开命令行(cmd/bash)
         - `$git config --list`
             - 简写 `$ git config -l`
     - 配置全局用户名
         - `$git config --global user.name  '你的用户名'`
             - 用户名: 可以随便写, 但是要记住, 一般我们按照电脑区分
     - 配置全局邮箱
         - `$git config --global user.email '你的邮箱''`
    - 如果没有进行配置, 那么你将来形成历史版本的时候会报错

# 本地操作

## 初始化
- 默认 git 安装好以后, 是不会管理你本地的任何一个'文件夹'
- 如果你希望这个文件夹被 git 管理
    - 你要告诉 git 来管理
    - 这个行为叫做 git 初始化
- 在你要的目录打开命令行
    - `$git init`
    - 该文件夹内会出现一个.git 的目录
- 有了.git
    - 当前文件夹就变成了一个 git 的本地仓库(local repository)
    - 从此该文件夹接受 git 的管理了
    - 该文件夹的所有后代文件夹都会被 git 管理
    - 注意: ==空文件夹不会被 git 管理==
    - 之后就可以在当前目录执行各种 git 指令了
- 仓库基本形态
    - 当一个文件夹变成了本地仓库以后
    - 会把这个本地仓库==虚拟==的变成 3 个
        - 工作区
            - 你能看到的所有内容
            - 包括你的代码
        - 暂存区
            - 保存你想形成历史版本的内容
            - 当历史版本形成以后这里清空
        - 历史区
            - 保留你的历史版本
            - ==只能把暂存区的所有内容形成版本==
    - 以上三个区域的可操作性型
        - 工作区添加到暂存区
        - 暂存区拉回到工作区
        - 暂存区形成历史区历史版本(所有的东西记下来了就是记下来了)

解释:
工作区
- 你的所有文件课件
- 进行代码书写和开发
- 所有代码在这里直接进行书写
暂存区
- 可以把工作区的内容复制一份放在暂存区
    - 复制一份: 虚拟的复制, 就是做一个记录
- 暂存区就是为了将来形成历史版本做准备的
历史区
- 形成并且保存历史版本
    - 把暂存区的所有内容, 形成一个历史版本
    - 历史版本: 虚拟的历史, 也是做了一个记录
- 将来如果你需要上传到远程
    - git 只能把历史区的所有内容上传到远程

## 查看暂存区状态
- 打开命令行, 目录切换到 .git/ 所在的目录
- 输入: `$git status`
- 就可以查看暂存区的当前状态

## 工作区和暂存区交互
- cmd: `$git add 文件名 `
   - 添加单文件到暂存区
- `$ git add 文件夹 `
   - 添加整个文件夹到暂存区
- `$ git add --all`
   - 简写: `$ git add .`
   - 添加工作区所有内容到暂存区

## 把暂存区的拉回到工作区
- 因为暂存区的所有内容会被形成历史版本
- 所以不想某个文件形成历史版本就需要拉回来

`-- 减 `
- `$ git reset HEAD --  文件名 `
    - 拉回单文件到工作区
- `$ git reset HEAD --  文件夹名 `
    - 把文件夹拉回工作区
- `$ git reset HEAD --  .`
    - 拉回暂存区所有内容到工作区

## 两个 git 相关文件
1.  `.gitignore`
    - 注意: 这个文件没有名字, 只有后缀
    - 作用: git 忽略文件
    - 你工作区的所有内容默认都是被 git 管理的(空文件除外)
    - 如果你不希望某一个文件被 git 管理
    - 你可以在.git/ 所在的目录建立一个.gitignore 文件
        - 在该文件内书写上你不需要管理的文件名或者文件夹名称

- 常用: 忽略 package-lock.json 和忽略 node_modules/
- 注意: 已经在暂存区的或者已经形成过历史版本的内容
    - 再次书写在.gitignore 文件里面就没有意义了


2.  `.gitkeep`
    - 注意: 这个文件没有名字, 只有后缀
    - 作用: git 保持文件
    - git 默认是不管理你的空文件夹的
    - 但是当项目刚刚建立之初, 有一些文件夹是没有内容的, 并且此时还需要保留文件夹结构
    - git 提供了一个.gitkeep 的文件
    - 目的就是为了保持文件夹结构
    - 你需要被 git 管理的空文件夹, 在内部添加一个.gitkeep 文件就行


## 历史版本
- 在.git 目录下
- `$ git commit -m  '简要说明'`  (markdown)
    - 简要说明: 对这次版本的简单说明, 可以是中文
- 注意: 如果你没有进行过全局配置,此时就会报错(没有签名就会报错)
    - 只要补充配置上全局用户名和全局邮箱即可
- 注意: 必须保证 暂存区有内容
    - 如果暂存区没有内容, 是不能形成历史版本的
    - 一旦形成历史版本, 是会把暂存区所有内容形成一个历史版本, 并且清空暂存区

### git log ->提交记录
- .git 所在目录下
- `$ git log`
- 注意: 查看的是当前时间轴上的==当前历史版本以及之前的历史版本==, 看不到之后的历史版本, 其实就是**提交记录**
- 注意: 倒序展示(先展示最近的)


### 回滚历史版本
- 目的 : 把工作区的内容还原到指定某一个历史版本时的状态
- `$ git reset --hard   版本 id`
    - 回退历史版本
- `$git reset --hard HEAD`
    - 回退到当前版本,HEAD 指向当前版本, 如果你修改了一些代码，想去除，就可以用 git reset --hard HEAD 一次性去除
- `$git push -f`
    - 强推, 本地优先

## 贮藏区
- 将暂存区的文件转移到贮藏区, 可以不进行 commit
- $ 作用: 将要提交的内容先全部贮藏, 之后再释放出来一次性提交
- $git stash -m '要记录的信息'
    - 将文件放入贮藏区
- $git stash list
    - 查看贮藏区列表
- $git stash apply
    - 将贮藏区的内容放出来到工作区
    - $git stash apply key(stash@{1})
        - 将具体文件释放出来
- $git stash clear
    - 清除贮藏记录



# 远程操作
git 远程操作
- 前提: 要有远程账号
    - github
    - gitee

1.  首次上传
    - 指代: 同一个本地仓库的首次上传
- 保证本次仓库内历史区有未上传版本
    - 本地仓库的历史区和远程不一样
- 建立一个远程仓库
    - 打开网站
    - 右上角加号
    - 新建仓库(new repository)
    - 填写仓库名称(不要用中文和特殊符号)
- & 把远程仓库地址和本地关联
    - 打开命令行, 切换到.git 目录下
    - 输入: `$git remote add`   变量名 远程地址
        - 你的地址太长了, 可以定义一个变量来表示这个地址
        - 今后使用这个变量的时候就是在使用这个远程地址
        - .git 中的 config 文件也能改
    - 其他命令
        - `$git remote -v`查看当前git仓库地址标题
        - `$git remote rm 仓库变量名`清空对应的git仓库地址
- 把本地内容上传到远程
    - `$git push -u`  仓库变量名 分支名称(详见解释 1)
- 一台电脑的第一次上传需要书写用户名和密码
    - 如果上传的是 github 填写的是 github 的账号和密码

2.  第二次上传
    - 指: 同一个本地仓库的第二次上传
    - 不需要关联仓库地址了
        - 直接上传即可
    - 如果需要新的仓库地址才需要关联

解释 1
- 解释上传指令中的-u
- 表示是否记录本次上传信息
- 当你第一次上传的时候
    - 假设你要传递到 first 地址的 a 分支
    - 如果你的指令是$git push -u  first a
        - 当你第二次上传还是向 first 的 a 上传
        - 只用书写 git push
        - 第二次向 second 地址的 b 分支上传的时候
        - 依旧需要书写 git push first b

- 解释 2
    - 用户名和密码
    - 当你填写一次用户名和密码后, 会自动记录下来(不管对错)
        - 如果第一次写错了, 那么后续的上传每一次都会出错
        - 需要手动清除凭证后再次上传,再次填写用户名和密码



## readme 文件
- 扩展一个 git 相关文件, readme.md
    - 名字必须是 readme.md, 大小写无所谓
- 这个文件放在哪一个目录下上传
    - 就是哪一个目录下的介绍文档
    - 会直接把 md 编译成 html 文件显示在仓库文档

## 拉取
- 第一次拉取远程代码
- 指: 没有本地对应仓库
- 第一次拉取远程仓库内容
    - 打开命令行, 切换到你想要的仓库存储位置
    - `$git clone 远程仓库地址 `
    - vscode 不能拉取
    - 猫猫头可以拉取
- 后续下载远程仓库
    - 指: 经过克隆以后, 后续还要下载同一个仓库内容
    - 切到对应仓库内
    - `$git pull`

>“git pull”命令主要用于取回远程主机指定分支的更新，再与本地的指定分支合并，语法为“git pull <远程主机名> <远程分支名>:<本地分支名>”；如果远程分支是与当前分支合并，则冒号后面的部分可以省略。
- ~ 拉取并且合并


# 变基-操作历史版本
- 很多公司会禁用这个指令(了解就行)
- 删了就找不回来了
    - 了解你历史版本,`git reflog`
```json
e6751ee (HEAD -> master, hello/master) HEAD@{0}: commit: 为了执行pull
2417c86 HEAD@{1}: commit: 更改和添加说明文档
b53f70a HEAD@{2}: commit: 添加说明文档
30fb531 HEAD@{3}: commit: 二次上传
5425d81 HEAD@{4}: commit (initial): 初始化
```
- 指令: `$git rebase -i  开始版本 id  结束版本 id`    !!!不推荐使用
- 意义: 重新操作哪些本地历史版本,**操作根基**


**另一种使用变基的场景:续接**
你要合并自己分支(feat(a))的代码到远程的分支(比如 master)上,但是远程的master 和比你拉出分支时候的代码更新, 所以就需要变基(先把本地 master 更新然后在 feat 分支上对 master 进行 rebase), 把基础变得和远程代码相同然后续上


# branch
- 所有的分支操作都是虚拟的操作
- 开辟分支的原则: 你站在哪个分支上开辟新分支, 那么新分支上的内容就是原分支所有内容复刻版
- 合并分支原则: 你只能站在某一个分支上, 把其他分支的内容合并到自己身上
- 切换分支的原则:要在当前分支把该处理的处理完毕, 再切换分支操作(把当前分支的内容都形成历史版本以后再切换分支)
- 删除分支原则: 被删除分支一定要是一个所有操作都处理完毕的分支, 然后再删除

## 本地分支
- 开启新分支
    - 在.git 所在的目录
    - `$git branch 分支名称 `
    - 会把当前分支的所有内容复制一份一模一样的放在新开辟的分支上(虚拟的)

- 查看所有分支
    - `$ git branch`

- 删除分支
    - 前提: ==你不能处在这个分支上, 不要删除 master 分支==
    - git 目录: `$git branch -d 分支名称 `
        - 如果你所删除的分支确实没有未完结操作
        - 那么就可以删除成功, 如果有未完结操作, 那么操作失败
    - 输入指令: `$git branch -D 分支名称 `
        - 会强制删除该分支, 包括该分支的所有内容
        - 不管是否有未完结操作,都会删除

- 切换分支
    - 打开命令行, 切换到.git/
    - `$ git checkout 分支名称 `

- 合并分支
    - 打开命令行, 切换目录到 git/所在目录
    - `$git merge 分支名称 `
    - 把目标分支的内容合并到自己当前所在的分支上


## 远程分支
- 当我们开始上传的时候
- 会写一个指令, 切换到要上传的分支
    - `$git push 仓库地址变量  分支名称 `
        - 分支名称表示的是远程分支的名称
        - 会把==当前分支的所有内容==上传到远程一份, 放在你命名的分支空间内
        - 推荐本地分支叫什么, 远程分支也叫什么

- 删除远程分支
    - 到.git/所在目录
    - `$git push 仓库地址变量 -d 分支名称 `
    - 只会删除远程分支
## 分支命名
master
- 主分支,线上分支,pr,mr 进行上线
release/pre 分支
dev
- 测试分支/联调分支
featureA
featureB


# 冲突
## 解决方式 1----stash
别人上传到远程仓库后，你没有及时的同步（、拉取）到本地，但是你同时又添加了一些内容（提交），以致于你在提交时，它会检测到你之前从远程仓库拉取的时候的仓库状态和现在的不一样。于是，它为了安全起见拒绝了你的提交（然后就报了这个错误）。

- git add .
- git stash
- git pull
- git stash apply
- 解决冲突
- git add .
- git commit -m 'message'
- git push



git pull = git fetch + git merge

## 解决方式 2 变基
（1）先把git的东西fetch到你本地然后merge后再push
   $ git fetch origin master
   $ git merge origin FETCH_HEAD 
   先抓取远程仓库的更新到本地，然后与你的本地仓库合并，（如果有冲突就要解决冲突后再合并，冲突问题比较复杂，这里就不详细说了），这样就可以使远程仓库和你本地仓库一致了，然后就可以提交修改了。

（2）这2句命令等价于
   $ git pull origin master
   - ~ 使得远程仓库和本地一致
   但是使用git fetch + git merge 更加安全。
（3）git pull --rebase origin master
   重定基，可以是历史更加统一，即使提交历史趋向于一条直线。

补充：他们之间的关系
git pull = git fetch + git merge FETCH_HEAD 
git pull --rebase =  git fetch + git rebase FETCH_HEAD




